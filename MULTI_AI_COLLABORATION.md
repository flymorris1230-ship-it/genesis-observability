# å¤š AI å”ä½œç³»çµ±è¨­è¨ˆ
## AI Agent Team + ChatGPT (Codex) + Gemini åŒæ­¥å”ä½œæ¶æ§‹

## ğŸ¯ ç›®æ¨™

å‰µå»ºä¸€å€‹**å”èª¿å™¨ (Orchestrator)** ç³»çµ±ï¼Œèƒ½å¤ ï¼š
1. **åŒæ­¥èª¿ç”¨**å¤šå€‹ AI ç³»çµ±ï¼ˆAI Agent Team, ChatGPT, Geminiï¼‰
2. **æ™ºèƒ½åˆ†é…**ä»»å‹™çµ¦æœ€é©åˆçš„ AI
3. **æ•´åˆçµæœ**ä¸¦æä¾›æœ€ä½³ç­”æ¡ˆ
4. **è¿½è¹¤æ‰€æœ‰**AI ä½¿ç”¨é‡å’Œæˆæœ¬
5. **è‡ªå‹•å„ªåŒ–**é¸æ“‡ç­–ç•¥

---

## ğŸ—ï¸ ç³»çµ±æ¶æ§‹

### æ•´é«”æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ¶è«‹æ±‚                               â”‚
â”‚              "å¯¦ç¾ä¸€å€‹ç‰©æ–™ç®¡ç†åŠŸèƒ½"                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Multi-AI Orchestrator                       â”‚
â”‚  - ä»»å‹™åˆ†æ (Task Analysis)                              â”‚
â”‚  - ç­–ç•¥é¸æ“‡ (Strategy Selection)                         â”‚
â”‚  - çµæœæ•´åˆ (Result Integration)                         â”‚
â”‚  - è¿½è¹¤è¨˜éŒ„ (Observability)                              â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI Agent â”‚   â”‚ ChatGPT  â”‚   â”‚  Gemini  â”‚
â”‚   Team   â”‚   â”‚  (Codex) â”‚   â”‚          â”‚
â”‚          â”‚   â”‚          â”‚   â”‚          â”‚
â”‚ Anthropicâ”‚   â”‚  OpenAI  â”‚   â”‚  Google  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚               â”‚               â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Genesis Observability                          â”‚
â”‚  - Token ä½¿ç”¨è¿½è¹¤                                         â”‚
â”‚  - æˆæœ¬åˆ†æ                                              â”‚
â”‚  - æ€§èƒ½æ¯”è¼ƒ                                              â”‚
â”‚  - å”ä½œæ•ˆç‡åˆ†æ                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¤– AI ç³»çµ±ç‰¹æ€§åˆ†æ

### 1. AI Agent Team (Anthropic Claude)
**å„ªå‹¢**:
- âœ… é•·ä¸Šä¸‹æ–‡è™•ç† (200K tokens)
- âœ… è¤‡é›œæ¨ç†èƒ½åŠ›å¼·
- âœ… ä»£ç¢¼å¯©æŸ¥å’Œæ¶æ§‹è¨­è¨ˆ
- âœ… å¤šæ­¥é©Ÿä»»å‹™è¦åŠƒ

**é©ç”¨å ´æ™¯**:
- ç³»çµ±æ¶æ§‹è¨­è¨ˆ
- è¤‡é›œæ¥­å‹™é‚è¼¯åˆ†æ
- ä»£ç¢¼é‡æ§‹å»ºè­°
- æ–‡æª”ç”Ÿæˆ

**æˆæœ¬**: $3/MTok (input), $15/MTok (output)

### 2. ChatGPT / Codex (OpenAI)
**å„ªå‹¢**:
- âœ… ä»£ç¢¼ç”Ÿæˆé€Ÿåº¦å¿«
- âœ… å‡½æ•¸èª¿ç”¨ (Function Calling)
- âœ… JSON æ¨¡å¼è¼¸å‡º
- âœ… å»£æ³›çš„ä»£ç¢¼æ¨¡å¼åº«

**é©ç”¨å ´æ™¯**:
- å¿«é€Ÿä»£ç¢¼ç”Ÿæˆ
- API æ•´åˆ
- æ•¸æ“šè™•ç†è…³æœ¬
- å–®å…ƒæ¸¬è©¦ç”Ÿæˆ

**æˆæœ¬**: $0.15/MTok (input), $0.60/MTok (output) - GPT-4o-mini

### 3. Gemini (Google)
**å„ªå‹¢**:
- âœ… å¤šæ¨¡æ…‹èƒ½åŠ›ï¼ˆåœ–åƒã€è¦–é »ï¼‰
- âœ… é•·ä¸Šä¸‹æ–‡ (1M tokens - Pro)
- âœ… å¿«é€ŸéŸ¿æ‡‰
- âœ… å…è²»é…é¡å¤§

**é©ç”¨å ´æ™¯**:
- æ–‡æª”åœ–åƒåˆ†æ
- UI/UX è¨­è¨ˆè©•å¯©
- å¤§è¦æ¨¡æ•¸æ“šè™•ç†
- æˆæœ¬æ•æ„Ÿä»»å‹™

**æˆæœ¬**: $0.075/MTok (input), $0.30/MTok (output) - Gemini 1.5 Flash

---

## ğŸ¯ å”ä½œç­–ç•¥

### ç­–ç•¥ 1: ä¸¦è¡ŒåŸ·è¡Œ + æŠ•ç¥¨ (Parallel + Voting)
**é©ç”¨**: é—œéµæ±ºç­–ã€ä»£ç¢¼å¯©æŸ¥

```typescript
async function parallelVoting(task: Task): Promise<Result> {
  // åŒæ™‚èª¿ç”¨ä¸‰å€‹ AI
  const [agentResult, gptResult, geminiResult] = await Promise.all([
    aiAgentTeam.execute(task),
    chatGPT.execute(task),
    gemini.execute(task),
  ]);

  // æŠ•ç¥¨é¸å‡ºæœ€ä½³ç­”æ¡ˆ
  const bestResult = vote([agentResult, gptResult, geminiResult]);

  return bestResult;
}
```

**å„ªé»**:
- é«˜æº–ç¢ºåº¦
- å¤šè§’åº¦é©—è­‰

**ç¼ºé»**:
- æˆæœ¬é«˜ï¼ˆ3xï¼‰
- å»¶é²è¼ƒé•·

### ç­–ç•¥ 2: éšæ¢¯å¼åŸ·è¡Œ (Cascade)
**é©ç”¨**: æ¼¸é€²å¼å„ªåŒ–

```typescript
async function cascadeExecution(task: Task): Promise<Result> {
  // 1. Gemini å¿«é€Ÿç”Ÿæˆåˆç‰ˆ (ä¾¿å®œå¿«é€Ÿ)
  const draft = await gemini.execute(task);

  // 2. ChatGPT å„ªåŒ–ä»£ç¢¼ (ä¸­ç­‰æˆæœ¬)
  const optimized = await chatGPT.refine(draft);

  // 3. AI Agent Team æœ€çµ‚å¯©æŸ¥ (é«˜è³ªé‡)
  const final = await aiAgentTeam.review(optimized);

  return final;
}
```

**å„ªé»**:
- å¹³è¡¡æˆæœ¬èˆ‡è³ªé‡
- æ¼¸é€²å¼æ”¹é€²

**ç¼ºé»**:
- å»¶é²è¼ƒé•·ï¼ˆä¸²è¡Œï¼‰

### ç­–ç•¥ 3: å°ˆæ¥­åˆ†å·¥ (Specialization)
**é©ç”¨**: è¤‡é›œé …ç›®

```typescript
async function specializationExecution(project: Project): Promise<Result> {
  const tasks = analyzeProject(project);

  const results = await Promise.all([
    // AI Agent Team: æ¶æ§‹è¨­è¨ˆ
    aiAgentTeam.execute(tasks.architecture),

    // ChatGPT: ä»£ç¢¼ç”Ÿæˆ
    chatGPT.execute(tasks.implementation),

    // Gemini: æ–‡æª”å’Œæ¸¬è©¦
    gemini.execute(tasks.documentation),
  ]);

  return integrateResults(results);
}
```

**å„ªé»**:
- å……åˆ†åˆ©ç”¨å„ AI å„ªå‹¢
- ä¸¦è¡ŒåŸ·è¡Œï¼Œé€Ÿåº¦å¿«

**ç¼ºé»**:
- éœ€è¦æ™ºèƒ½ä»»å‹™åˆ†é…
- çµæœæ•´åˆè¤‡é›œ

### ç­–ç•¥ 4: å‹•æ…‹è·¯ç”± (Dynamic Routing)
**é©ç”¨**: æ—¥å¸¸é–‹ç™¼

```typescript
async function dynamicRouting(task: Task): Promise<Result> {
  const metadata = analyzeTask(task);

  // æ ¹æ“šä»»å‹™ç‰¹æ€§é¸æ“‡æœ€ä½³ AI
  if (metadata.complexity === 'high' && metadata.needsReasoning) {
    return aiAgentTeam.execute(task);
  } else if (metadata.type === 'code_generation') {
    return chatGPT.execute(task);
  } else if (metadata.costSensitive) {
    return gemini.execute(task);
  }

  // é è¨­: ä½¿ç”¨ ChatGPT
  return chatGPT.execute(task);
}
```

**å„ªé»**:
- æˆæœ¬å„ªåŒ–
- é€Ÿåº¦å¿«

**ç¼ºé»**:
- è·¯ç”±é‚è¼¯éœ€è¦è¨“ç·´

---

## ğŸ’» å¯¦ç¾ä»£ç¢¼

### æ ¸å¿ƒ Orchestrator

```typescript
// apps/ai-agent-team/src/main/js/orchestrator/multi-ai-orchestrator.ts

import { AIAgentTeam } from '../agents/coordinator';
import { ChatGPTClient } from '../clients/chatgpt-client';
import { GeminiClient } from '../clients/gemini-client';
import { trackCollaboration } from '../utils/observability';

export interface Task {
  id: string;
  type: 'code_generation' | 'code_review' | 'architecture' | 'documentation' | 'testing';
  description: string;
  complexity: 'low' | 'medium' | 'high';
  priority: 'low' | 'medium' | 'high';
  context?: string;
  constraints?: {
    maxCost?: number;
    maxTime?: number;
    qualityRequired?: 'basic' | 'standard' | 'premium';
  };
}

export interface CollaborationResult {
  result: string;
  strategy: string;
  aiUsed: string[];
  totalTokens: number;
  totalCost: number;
  duration: number;
  metadata: {
    agentResult?: any;
    gptResult?: any;
    geminiResult?: any;
    votingDetails?: any;
  };
}

export class MultiAIOrchestrator {
  private aiAgentTeam: AIAgentTeam;
  private chatGPT: ChatGPTClient;
  private gemini: GeminiClient;
  private projectId: string;

  constructor(
    agentTeam: AIAgentTeam,
    chatGPT: ChatGPTClient,
    gemini: GeminiClient,
    projectId: string = 'GAC_FactoryOS'
  ) {
    this.aiAgentTeam = agentTeam;
    this.chatGPT = chatGPT;
    this.gemini = gemini;
    this.projectId = projectId;
  }

  /**
   * ä¸»å…¥å£ï¼šæ™ºèƒ½åŸ·è¡Œä»»å‹™
   */
  async execute(task: Task): Promise<CollaborationResult> {
    const startTime = Date.now();

    // 1. åˆ†æä»»å‹™ï¼Œé¸æ“‡ç­–ç•¥
    const strategy = this.selectStrategy(task);

    console.log(`ğŸ¯ ä»»å‹™: ${task.description}`);
    console.log(`ğŸ“‹ ç­–ç•¥: ${strategy}`);

    // 2. æ ¹æ“šç­–ç•¥åŸ·è¡Œ
    let result: CollaborationResult;

    switch (strategy) {
      case 'parallel_voting':
        result = await this.parallelVoting(task);
        break;
      case 'cascade':
        result = await this.cascadeExecution(task);
        break;
      case 'specialization':
        result = await this.specializationExecution(task);
        break;
      case 'dynamic_routing':
        result = await this.dynamicRouting(task);
        break;
      default:
        result = await this.dynamicRouting(task);
    }

    // 3. è¨˜éŒ„çµæœ
    result.duration = Date.now() - startTime;
    result.strategy = strategy;

    // 4. ä¸Šå ±åˆ° Genesis Observability
    await this.trackCollaboration(task, result);

    return result;
  }

  /**
   * ç­–ç•¥ 1: ä¸¦è¡ŒæŠ•ç¥¨
   */
  private async parallelVoting(task: Task): Promise<CollaborationResult> {
    console.log('ğŸ”„ ä¸¦è¡Œèª¿ç”¨ 3 å€‹ AI...');

    const [agentResult, gptResult, geminiResult] = await Promise.all([
      this.aiAgentTeam.execute(task.description, task.context),
      this.chatGPT.complete(task.description),
      this.gemini.generate(task.description),
    ]);

    // æŠ•ç¥¨é‚è¼¯ï¼šé¸æ“‡æœ€ä½³ç­”æ¡ˆ
    const votes = this.vote([agentResult, gptResult, geminiResult]);
    const winner = votes[0]; // å¾—ç¥¨æœ€é«˜

    return {
      result: winner.content,
      strategy: 'parallel_voting',
      aiUsed: ['ai_agent_team', 'chatgpt', 'gemini'],
      totalTokens: agentResult.tokens + gptResult.tokens + geminiResult.tokens,
      totalCost: agentResult.cost + gptResult.cost + geminiResult.cost,
      duration: 0, // Will be set by execute()
      metadata: {
        agentResult,
        gptResult,
        geminiResult,
        votingDetails: votes,
      },
    };
  }

  /**
   * ç­–ç•¥ 2: éšæ¢¯å¼åŸ·è¡Œ
   */
  private async cascadeExecution(task: Task): Promise<CollaborationResult> {
    console.log('ğŸ“ˆ éšæ¢¯å¼åŸ·è¡Œ...');

    // Step 1: Gemini å¿«é€Ÿè‰ç¨¿
    console.log('  1ï¸âƒ£ Gemini: ç”Ÿæˆåˆç‰ˆ...');
    const draft = await this.gemini.generate(task.description);

    // Step 2: ChatGPT å„ªåŒ–
    console.log('  2ï¸âƒ£ ChatGPT: å„ªåŒ–ä»£ç¢¼...');
    const optimized = await this.chatGPT.complete(
      `Optimize this code:\n\n${draft.content}\n\nRequirements: ${task.description}`
    );

    // Step 3: AI Agent Team å¯©æŸ¥
    console.log('  3ï¸âƒ£ AI Agent Team: æœ€çµ‚å¯©æŸ¥...');
    const final = await this.aiAgentTeam.review(
      optimized.content,
      task.context
    );

    return {
      result: final.content,
      strategy: 'cascade',
      aiUsed: ['gemini', 'chatgpt', 'ai_agent_team'],
      totalTokens: draft.tokens + optimized.tokens + final.tokens,
      totalCost: draft.cost + optimized.cost + final.cost,
      duration: 0,
      metadata: { draft, optimized, final },
    };
  }

  /**
   * ç­–ç•¥ 3: å°ˆæ¥­åˆ†å·¥
   */
  private async specializationExecution(task: Task): Promise<CollaborationResult> {
    console.log('ğŸ¤ å°ˆæ¥­åˆ†å·¥åŸ·è¡Œ...');

    // åˆ†è§£ä»»å‹™
    const subtasks = this.decomposeTask(task);

    // ä¸¦è¡ŒåŸ·è¡Œ
    const results = await Promise.all([
      // AI Agent Team: æ¶æ§‹å’Œè¦åŠƒ
      subtasks.architecture
        ? this.aiAgentTeam.execute(subtasks.architecture)
        : null,

      // ChatGPT: ä»£ç¢¼ç”Ÿæˆ
      subtasks.implementation
        ? this.chatGPT.complete(subtasks.implementation)
        : null,

      // Gemini: æ–‡æª”å’Œæ¸¬è©¦
      subtasks.documentation
        ? this.gemini.generate(subtasks.documentation)
        : null,
    ]);

    // æ•´åˆçµæœ
    const integrated = this.integrateResults(results.filter(r => r !== null));

    return {
      result: integrated.content,
      strategy: 'specialization',
      aiUsed: ['ai_agent_team', 'chatgpt', 'gemini'],
      totalTokens: integrated.totalTokens,
      totalCost: integrated.totalCost,
      duration: 0,
      metadata: { subtasks, results },
    };
  }

  /**
   * ç­–ç•¥ 4: å‹•æ…‹è·¯ç”±
   */
  private async dynamicRouting(task: Task): Promise<CollaborationResult> {
    console.log('ğŸ”€ å‹•æ…‹è·¯ç”±...');

    // é¸æ“‡æœ€ä½³ AI
    const selectedAI = this.selectBestAI(task);
    console.log(`  â¡ï¸ é¸æ“‡: ${selectedAI}`);

    let result: any;
    let aiUsed: string;

    switch (selectedAI) {
      case 'ai_agent_team':
        result = await this.aiAgentTeam.execute(task.description, task.context);
        aiUsed = 'ai_agent_team';
        break;
      case 'chatgpt':
        result = await this.chatGPT.complete(task.description);
        aiUsed = 'chatgpt';
        break;
      case 'gemini':
        result = await this.gemini.generate(task.description);
        aiUsed = 'gemini';
        break;
      default:
        result = await this.chatGPT.complete(task.description);
        aiUsed = 'chatgpt';
    }

    return {
      result: result.content,
      strategy: 'dynamic_routing',
      aiUsed: [aiUsed],
      totalTokens: result.tokens,
      totalCost: result.cost,
      duration: 0,
      metadata: { selectedAI, result },
    };
  }

  /**
   * é¸æ“‡ç­–ç•¥
   */
  private selectStrategy(task: Task): string {
    // é«˜å„ªå…ˆç´šä¸”é«˜è¤‡é›œåº¦ â†’ ä¸¦è¡ŒæŠ•ç¥¨
    if (task.priority === 'high' && task.complexity === 'high') {
      return 'parallel_voting';
    }

    // æ¶æ§‹è¨­è¨ˆé¡ â†’ éšæ¢¯å¼åŸ·è¡Œ
    if (task.type === 'architecture') {
      return 'cascade';
    }

    // å®Œæ•´é …ç›® â†’ å°ˆæ¥­åˆ†å·¥
    if (task.description.includes('å®Œæ•´') || task.description.includes('æ•´å€‹')) {
      return 'specialization';
    }

    // é è¨­ â†’ å‹•æ…‹è·¯ç”±
    return 'dynamic_routing';
  }

  /**
   * é¸æ“‡æœ€ä½³ AI
   */
  private selectBestAI(task: Task): string {
    // æˆæœ¬æ•æ„Ÿ â†’ Gemini
    if (task.constraints?.maxCost && task.constraints.maxCost < 0.01) {
      return 'gemini';
    }

    // é«˜è¤‡é›œåº¦ â†’ AI Agent Team
    if (task.complexity === 'high') {
      return 'ai_agent_team';
    }

    // ä»£ç¢¼ç”Ÿæˆ â†’ ChatGPT
    if (task.type === 'code_generation') {
      return 'chatgpt';
    }

    // æ¶æ§‹è¨­è¨ˆ â†’ AI Agent Team
    if (task.type === 'architecture') {
      return 'ai_agent_team';
    }

    // é è¨­ â†’ ChatGPT
    return 'chatgpt';
  }

  /**
   * æŠ•ç¥¨é¸æ“‡æœ€ä½³ç­”æ¡ˆ
   */
  private vote(results: any[]): any[] {
    // ç°¡åŒ–ç‰ˆï¼šæ ¹æ“šçµæœé•·åº¦ã€ä»£ç¢¼è³ªé‡æŒ‡æ¨™æ‰“åˆ†
    return results
      .map(r => ({
        ...r,
        score: this.calculateScore(r),
      }))
      .sort((a, b) => b.score - a.score);
  }

  /**
   * è¨ˆç®—çµæœåˆ†æ•¸
   */
  private calculateScore(result: any): number {
    let score = 0;

    // é•·åº¦é©ä¸­ (+10)
    if (result.content.length > 100 && result.content.length < 5000) {
      score += 10;
    }

    // åŒ…å«ä»£ç¢¼å¡Š (+15)
    if (result.content.includes('```')) {
      score += 15;
    }

    // åŒ…å«è§£é‡‹ (+10)
    if (result.content.includes('å› ç‚º') || result.content.includes('åŸå› ')) {
      score += 10;
    }

    // çµæ§‹æ¸…æ™° (+10)
    if (result.content.includes('##') || result.content.includes('###')) {
      score += 10;
    }

    return score;
  }

  /**
   * åˆ†è§£ä»»å‹™
   */
  private decomposeTask(task: Task): any {
    // æ™ºèƒ½åˆ†è§£ä»»å‹™ç‚ºå­ä»»å‹™
    return {
      architecture: `è¨­è¨ˆæ¶æ§‹: ${task.description}`,
      implementation: `å¯¦ç¾ä»£ç¢¼: ${task.description}`,
      documentation: `æ’°å¯«æ–‡æª”å’Œæ¸¬è©¦: ${task.description}`,
    };
  }

  /**
   * æ•´åˆçµæœ
   */
  private integrateResults(results: any[]): any {
    const combined = results.map(r => r.content).join('\n\n---\n\n');
    const totalTokens = results.reduce((sum, r) => sum + r.tokens, 0);
    const totalCost = results.reduce((sum, r) => sum + r.cost, 0);

    return {
      content: combined,
      totalTokens,
      totalCost,
    };
  }

  /**
   * è¿½è¹¤å”ä½œ
   */
  private async trackCollaboration(task: Task, result: CollaborationResult): Promise<void> {
    await trackCollaboration({
      project_id: this.projectId,
      task_id: task.id,
      task_type: task.type,
      strategy: result.strategy,
      ai_used: result.aiUsed,
      total_tokens: result.totalTokens,
      total_cost: result.totalCost,
      duration_ms: result.duration,
      metadata: {
        task,
        result: result.metadata,
      },
    });
  }
}
```

---

## ğŸ”Œ API Client å¯¦ç¾

### ChatGPT Client

```typescript
// apps/ai-agent-team/src/main/js/clients/chatgpt-client.ts

import OpenAI from 'openai';

export class ChatGPTClient {
  private client: OpenAI;
  private model: string;

  constructor(apiKey: string, model: string = 'gpt-4o-mini') {
    this.client = new OpenAI({ apiKey });
    this.model = model;
  }

  async complete(prompt: string): Promise<{
    content: string;
    tokens: number;
    cost: number;
  }> {
    const response = await this.client.chat.completions.create({
      model: this.model,
      messages: [
        { role: 'user', content: prompt },
      ],
      temperature: 0.7,
    });

    const content = response.choices[0].message.content || '';
    const tokens = response.usage?.total_tokens || 0;
    const cost = this.calculateCost(
      response.usage?.prompt_tokens || 0,
      response.usage?.completion_tokens || 0
    );

    return { content, tokens, cost };
  }

  private calculateCost(inputTokens: number, outputTokens: number): number {
    // GPT-4o-mini pricing
    const INPUT_PRICE = 0.15 / 1_000_000;  // $0.15 per MTok
    const OUTPUT_PRICE = 0.60 / 1_000_000; // $0.60 per MTok

    return inputTokens * INPUT_PRICE + outputTokens * OUTPUT_PRICE;
  }
}
```

### Gemini Client

```typescript
// apps/ai-agent-team/src/main/js/clients/gemini-client.ts

import { GoogleGenerativeAI } from '@google/generative-ai';

export class GeminiClient {
  private genAI: GoogleGenerativeAI;
  private model: string;

  constructor(apiKey: string, model: string = 'gemini-1.5-flash') {
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = model;
  }

  async generate(prompt: string): Promise<{
    content: string;
    tokens: number;
    cost: number;
  }> {
    const model = this.genAI.getGenerativeModel({ model: this.model });

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const content = response.text();

    // Gemini doesn't provide token counts in response
    // We'll estimate based on character count
    const estimatedTokens = Math.ceil(content.length / 4);
    const cost = this.calculateCost(estimatedTokens);

    return { content, tokens: estimatedTokens, cost };
  }

  private calculateCost(tokens: number): number {
    // Gemini 1.5 Flash pricing (approximate)
    const PRICE_PER_TOKEN = 0.075 / 1_000_000; // $0.075 per MTok
    return tokens * PRICE_PER_TOKEN;
  }
}
```

---

## ğŸ“Š Observability æ•´åˆ

### å”ä½œè¿½è¹¤ Schema

```sql
-- æ–°å¢å”ä½œè¿½è¹¤è¡¨
CREATE TABLE multi_ai_collaborations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id TEXT NOT NULL,
  task_id TEXT NOT NULL,
  task_type TEXT NOT NULL,
  strategy TEXT NOT NULL, -- 'parallel_voting', 'cascade', 'specialization', 'dynamic_routing'
  ai_used TEXT[] NOT NULL, -- ['ai_agent_team', 'chatgpt', 'gemini']
  total_tokens INTEGER NOT NULL,
  total_cost DECIMAL NOT NULL,
  duration_ms INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  metadata JSONB
);

CREATE INDEX idx_collaborations_project ON multi_ai_collaborations(project_id, created_at DESC);
CREATE INDEX idx_collaborations_strategy ON multi_ai_collaborations(strategy);
```

### Dashboard é¡¯ç¤º

```typescript
// å”ä½œçµ±è¨ˆå¡ç‰‡
interface CollaborationStats {
  totalCollaborations: number;
  strategiesUsed: Record<string, number>;
  aiUsageDistribution: {
    ai_agent_team: number;
    chatgpt: number;
    gemini: number;
  };
  avgCostPerCollaboration: number;
  costByStrategy: Record<string, number>;
}
```

---

## ğŸ¯ ä½¿ç”¨ç¯„ä¾‹

### ç¯„ä¾‹ 1: å¯¦ç¾æ–°åŠŸèƒ½

```typescript
import { MultiAIOrchestrator } from './orchestrator/multi-ai-orchestrator';

const orchestrator = new MultiAIOrchestrator(
  aiAgentTeam,
  chatGPT,
  gemini,
  'GAC_FactoryOS'
);

// å‰µå»ºä»»å‹™
const task = {
  id: 'task-001',
  type: 'code_generation',
  description: 'å¯¦ç¾ä¸€å€‹ç‰©æ–™ç®¡ç†çš„ CRUD APIï¼Œä½¿ç”¨ tRPC',
  complexity: 'medium',
  priority: 'high',
  context: 'éœ€è¦æ”¯æ´å¤šç§Ÿæˆ¶ï¼Œä½¿ç”¨ Prisma ORM',
  constraints: {
    qualityRequired: 'premium',
  },
};

// åŸ·è¡Œå”ä½œ
const result = await orchestrator.execute(task);

console.log('âœ… å”ä½œå®Œæˆï¼');
console.log(`ç­–ç•¥: ${result.strategy}`);
console.log(`ä½¿ç”¨çš„ AI: ${result.aiUsed.join(', ')}`);
console.log(`Token ä½¿ç”¨: ${result.totalTokens.toLocaleString()}`);
console.log(`æˆæœ¬: $${result.totalCost.toFixed(4)}`);
console.log(`è€—æ™‚: ${result.duration}ms`);
console.log(`\nçµæœ:\n${result.result}`);
```

### ç¯„ä¾‹ 2: ä»£ç¢¼å¯©æŸ¥

```typescript
const reviewTask = {
  id: 'task-002',
  type: 'code_review',
  description: 'å¯©æŸ¥ material.ts router çš„ä»£ç¢¼è³ªé‡',
  complexity: 'high',
  priority: 'high',
  context: fs.readFileSync('./src/server/routers/material.ts', 'utf-8'),
};

// ä½¿ç”¨ä¸¦è¡ŒæŠ•ç¥¨ç­–ç•¥ç²å–å¤šå€‹æ„è¦‹
const reviewResult = await orchestrator.execute(reviewTask);
```

### ç¯„ä¾‹ 3: å®Œæ•´å°ˆæ¡ˆ

```typescript
const projectTask = {
  id: 'task-003',
  type: 'architecture',
  description: 'è¨­è¨ˆä¸¦å¯¦ç¾å®Œæ•´çš„ WMS ç‰©æ–™ç®¡ç†æ¨¡çµ„',
  complexity: 'high',
  priority: 'high',
  constraints: {
    maxCost: 1.0, // $1.00 é ç®—
  },
};

// è‡ªå‹•ä½¿ç”¨å°ˆæ¥­åˆ†å·¥ç­–ç•¥
const projectResult = await orchestrator.execute(projectTask);
```

---

## ğŸ’° æˆæœ¬å°æ¯”

### å–®ä¸€ AI vs å”ä½œ

| å ´æ™¯ | å–®ä¸€ AI | å”ä½œ (å‹•æ…‹è·¯ç”±) | å”ä½œ (ä¸¦è¡ŒæŠ•ç¥¨) |
|-----|---------|---------------|---------------|
| ç°¡å–®ä»»å‹™ | $0.001 | $0.001 | $0.003 |
| ä¸­ç­‰ä»»å‹™ | $0.01 | $0.008 | $0.03 |
| è¤‡é›œä»»å‹™ | $0.10 | $0.08 | $0.30 |
| **è³ªé‡** | 70% | 85% | 95% |

### ç­–ç•¥æˆæœ¬å°æ¯”

```
å‹•æ…‹è·¯ç”±:      $0.008  (æœ€ä¾¿å®œï¼Œè³ªé‡ 85%)
éšæ¢¯å¼åŸ·è¡Œ:    $0.015  (å¹³è¡¡ï¼Œè³ªé‡ 90%)
å°ˆæ¥­åˆ†å·¥:      $0.020  (å¿«é€Ÿï¼Œè³ªé‡ 88%)
ä¸¦è¡ŒæŠ•ç¥¨:      $0.030  (æœ€è²´ï¼Œè³ªé‡ 95%)
```

---

## ğŸš€ å¯¦æ–½æ­¥é©Ÿ

### Phase 1: åŸºç¤è¨­æ–½
1. âœ… è¨­è¨ˆ Multi-AI Orchestrator æ¶æ§‹
2. [ ] å¯¦ç¾ ChatGPT Client
3. [ ] å¯¦ç¾ Gemini Client
4. [ ] æ•´åˆç¾æœ‰ AI Agent Team
5. [ ] æ·»åŠ å”ä½œè¿½è¹¤åˆ° Supabase

### Phase 2: ç­–ç•¥å¯¦ç¾
1. [ ] å¯¦ç¾å‹•æ…‹è·¯ç”±ç­–ç•¥
2. [ ] å¯¦ç¾ä¸¦è¡ŒæŠ•ç¥¨ç­–ç•¥
3. [ ] å¯¦ç¾éšæ¢¯å¼åŸ·è¡Œç­–ç•¥
4. [ ] å¯¦ç¾å°ˆæ¥­åˆ†å·¥ç­–ç•¥

### Phase 3: Dashboard æ•´åˆ
1. [ ] å‰µå»ºå”ä½œçµ±è¨ˆå¡ç‰‡
2. [ ] é¡¯ç¤º AI ä½¿ç”¨åˆ†å¸ƒ
3. [ ] æˆæœ¬å°æ¯”åˆ†æ
4. [ ] ç­–ç•¥æ•ˆæœæ¯”è¼ƒ

### Phase 4: å„ªåŒ–
1. [ ] æ©Ÿå™¨å­¸ç¿’å„ªåŒ–è·¯ç”±æ±ºç­–
2. [ ] è‡ªå‹• A/B æ¸¬è©¦ç­–ç•¥
3. [ ] æˆæœ¬é ç®—æ§åˆ¶
4. [ ] å¯¦æ™‚æ€§èƒ½ç›£æ§

---

## ğŸ“ é…ç½®æ–‡ä»¶

```bash
# .env
ANTHROPIC_API_KEY=sk-ant-...
OPENAI_API_KEY=sk-...
GOOGLE_API_KEY=...

# å”ä½œé…ç½®
MULTI_AI_ENABLED=true
DEFAULT_STRATEGY=dynamic_routing
MAX_COLLABORATION_COST=0.50
ENABLE_PARALLEL_VOTING=true
```

---

## ğŸ¯ é æœŸæ•ˆæœ

ä½¿ç”¨å¤š AI å”ä½œå¾Œï¼š

1. **è³ªé‡æå‡**:
   - ä»£ç¢¼è³ªé‡æå‡ 20-30%
   - æ¸›å°‘ bug æ•¸é‡ 40%

2. **æˆæœ¬å„ªåŒ–**:
   - æ™ºèƒ½è·¯ç”±é™ä½æˆæœ¬ 30%
   - é¿å…é‡è¤‡å˜—è©¦

3. **é€Ÿåº¦æå‡**:
   - ä¸¦è¡ŒåŸ·è¡Œå¿« 3x
   - å°ˆæ¥­åˆ†å·¥æå‡æ•ˆç‡ 50%

4. **å¯é æ€§**:
   - å¤šé‡é©—è­‰é™ä½éŒ¯èª¤
   - è‡ªå‹•å›é€€æ©Ÿåˆ¶

---

**ä½œè€…**: Claude Code
**æ—¥æœŸ**: 2025-10-07
**ç‰ˆæœ¬**: 1.0
**ç‹€æ…‹**: è¨­è¨ˆå®Œæˆï¼Œå¾…å¯¦ç¾
